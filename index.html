<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orthogonal Trajectory Solver</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            padding: 30px 0;
            background: linear-gradient(135deg, #4b6cb7 0%, #182848 100%);
            color: white;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .main-content {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            margin-bottom: 40px;
        }
        
        .input-section {
            flex: 1;
            min-width: 300px;
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        
        .visualization-section {
            flex: 2;
            min-width: 300px;
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            display: flex;
            flex-direction: column;
        }
        
        .section-title {
            font-size: 1.4rem;
            color: #2c3e50;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #eee;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #34495e;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 1rem;
            transition: border 0.3s;
        }
        
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #4b6cb7;
        }
        
        textarea {
            resize: vertical;
            min-height: 100px;
            font-family: monospace;
        }
        
        .formula-preview {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #4b6cb7;
            margin: 15px 0;
            font-family: 'Cambria', serif;
            font-size: 1.1rem;
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 25px;
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .btn-primary {
            background-color: #4b6cb7;
            color: white;
            flex: 1;
        }
        
        .btn-primary:hover {
            background-color: #3a5795;
            transform: translateY(-2px);
        }
        
        .btn-secondary {
            background-color: #f1f5f9;
            color: #333;
            flex: 1;
        }
        
        .btn-secondary:hover {
            background-color: #e2e8f0;
        }
        
        .btn-icon {
            font-size: 1.1rem;
        }
        
        .canvas-container {
            flex: 1;
            background-color: #f8fafc;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 350px;
            border: 1px dashed #cbd5e1;
            margin-bottom: 20px;
        }
        
        #graphCanvas {
            width: 100%;
            height: 100%;
        }
        
        .results-section {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            margin-bottom: 40px;
        }
        
        .results-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .result-box {
            background-color: #f8fafc;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #4b6cb7;
        }
        
        .result-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .result-content {
            font-family: 'Courier New', monospace;
            background-color: white;
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            white-space: pre-wrap;
        }
        
        .instructions {
            background-color: #e8f4fd;
            padding: 20px;
            border-radius: 8px;
            margin-top: 30px;
            border-left: 4px solid #3498db;
        }
        
        .instructions h3 {
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .instructions ul {
            padding-left: 20px;
        }
        
        .instructions li {
            margin-bottom: 8px;
        }
        
        .examples {
            background-color: #f0f7f0;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            border-left: 4px solid #27ae60;
        }
        
        .examples h3 {
            margin-bottom: 15px;
            color: #2c3e50;
        }
        
        .example-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        
        .example-btn {
            background-color: #2ecc71;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.3s;
        }
        
        .example-btn:hover {
            background-color: #27ae60;
        }
        
        .detected-method {
            background-color: #fff8e1;
            padding: 12px;
            border-radius: 6px;
            margin-top: 15px;
            font-size: 0.95rem;
            border-left: 4px solid #ffb300;
        }
        
        .method-name {
            font-weight: 600;
            color: #e65100;
        }
        
        footer {
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
            font-size: 0.9rem;
            border-top: 1px solid #eee;
            margin-top: 30px;
        }
        
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            .example-buttons {
                flex-direction: column;
            }
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }
        
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top: 4px solid #4b6cb7;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-project-diagram"></i> Orthogonal Trajectory Solver</h1>
            <p class="subtitle">Visualize and calculate orthogonal trajectories for families of curves. Enter a family of curves and get their orthogonal trajectories with step-by-step solutions.</p>
        </header>
        
        <div class="main-content">
            <section class="input-section">
                <h2 class="section-title"><i class="fas fa-edit"></i> Input Parameters</h2>
                
                <div class="input-group">
                    <label for="curveFamily"><i class="fas fa-function"></i> Family of Curves</label>
                    <input type="text" id="curveFamily" placeholder="e.g., y = kx, x² + y² = a², y² = 4ax">
                    <p class="formula-preview">Preview: <span id="formulaPreview">y = kx</span></p>
                </div>
                
                <div class="input-group">
                    <label for="variable"><i class="fas fa-atom"></i> Parameter Variable (Optional)</label>
                    <input type="text" id="variable" placeholder="Auto-detected if not specified">
                </div>
                
                <div class="input-group">
                    <label for="coordinates"><i class="fas fa-crosshairs"></i> Point Coordinates (Optional)</label>
                    <input type="text" id="coordinates" placeholder="e.g., (2, 3)">
                </div>
                
                <div id="methodDetection" class="detected-method">
                    <i class="fas fa-cogs"></i> Method will be auto-detected: <span class="method-name" id="detectedMethod">Not detected yet</span>
                </div>
                
                <div class="button-group">
                    <button class="btn-primary" id="solveBtn">
                        <i class="fas fa-calculator btn-icon"></i> Solve Orthogonal Trajectories
                    </button>
                    <button class="btn-secondary" id="clearBtn">
                        <i class="fas fa-broom btn-icon"></i> Clear All
                    </button>
                </div>
                
                <div class="loading" id="loadingIndicator">
                    <div class="spinner"></div>
                    <p>Calculating orthogonal trajectories...</p>
                </div>
            </section>
            
            <section class="visualization-section">
                <h2 class="section-title"><i class="fas fa-chart-line"></i> Graph Visualization</h2>
                
                <div class="canvas-container">
                    <canvas id="graphCanvas" width="800" height="400"></canvas>
                </div>
                
                <div class="button-group">
                    <button class="btn-secondary" id="zoomInBtn">
                        <i class="fas fa-search-plus btn-icon"></i> Zoom In
                    </button>
                    <button class="btn-secondary" id="zoomOutBtn">
                        <i class="fas fa-search-minus btn-icon"></i> Zoom Out
                    </button>
                    <button class="btn-secondary" id="resetViewBtn">
                        <i class="fas fa-sync-alt btn-icon"></i> Reset View
                    </button>
                </div>
            </section>
        </div>
        
        <section class="results-section">
            <h2 class="section-title"><i class="fas fa-poll"></i> Results</h2>
            
            <div class="results-container">
                <div class="result-box">
                    <div class="result-title">Orthogonal Trajectory Equation</div>
                    <div class="result-content" id="trajectoryResult">Enter a family of curves and click "Solve" to see the result.</div>
                </div>
                
                <div class="result-box">
                    <div class="result-title">Step-by-Step Solution</div>
                    <div class="result-content" id="stepByStepResult">The step-by-step solution will appear here.</div>
                </div>
                
                <div class="result-box">
                    <div class="result-title">Properties</div>
                    <div class="result-content" id="propertiesResult">
                        • Type of curves: --
                        • Detected method: --
                        • Intersection angle: 90°
                    </div>
                </div>
            </div>
        </section>
        
        <div class="examples">
            <h3><i class="fas fa-lightbulb"></i> Try These Examples</h3>
            <p>Click any example to load it into the solver:</p>
            <div class="example-buttons">
                <button class="example-btn" data-example="y = kx">Straight lines through origin</button>
                <button class="example-btn" data-example="y = k/x">Rectangular hyperbolas</button>
                <button class="example-btn" data-example="y = kx^2">Parabolas through origin</button>
                <button class="example-btn" data-example="x^2 + y^2 = a^2">Concentric circles</button>
                <button class="example-btn" data-example="y^2 = 4ax">Right-opening parabolas</button>
                <button class="example-btn" data-example="x^2/a^2 + y^2/b^2 = 1">Ellipses</button>
                <button class="example-btn" data-example="xy = c">Rectangular hyperbolas (rotated)</button>
            </div>
        </div>
        
        <div class="instructions">
            <h3><i class="fas fa-lightbulb"></i> How to Use This Solver</h3>
            <ul>
                <li>Enter a family of curves in the input field. The solver will automatically detect the type and method.</li>
                <li>Parameter variable is auto-detected (common ones: k, a, b, c) but you can specify if needed.</li>
                <li>Optionally, enter a point to find the specific orthogonal curve passing through it.</li>
                <li>Click "Solve Orthogonal Trajectories" to calculate and visualize the results.</li>
                <li>Use the example buttons to quickly try different curve families.</li>
                <li>Use the visualization controls to zoom in/out and reset the graph view.</li>
            </ul>
        </div>
        
        <footer>
            <p>Orthogonal Trajectory Solver &copy; 2023 | Mathematical Visualization Tool</p>
            <p>This tool calculates orthogonal trajectories for families of curves using differential equations.</p>
        </footer>
    </div>

    <script>
        // DOM elements
        const curveFamilyInput = document.getElementById('curveFamily');
        const formulaPreview = document.getElementById('formulaPreview');
        const variableInput = document.getElementById('variable');
        const detectedMethod = document.getElementById('detectedMethod');
        const solveBtn = document.getElementById('solveBtn');
        const clearBtn = document.getElementById('clearBtn');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const trajectoryResult = document.getElementById('trajectoryResult');
        const stepByStepResult = document.getElementById('stepByStepResult');
        const propertiesResult = document.getElementById('propertiesResult');
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        const exampleButtons = document.querySelectorAll('.example-btn');
        
        // Graph controls
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const resetViewBtn = document.getElementById('resetViewBtn');
        
        // Graph settings
        let scale = 40;
        let offsetX = canvas.width / 2;
        let offsetY = canvas.height / 2;
        
        // Curve detection and solution data
        const curveTypes = {
            linear: { name: "Linear", method: "Differentiation", param: "k" },
            circle: { name: "Circle", method: "Implicit Differentiation", param: "a" },
            parabola: { name: "Parabola", method: "Differentiation", param: "k" },
            ellipse: { name: "Ellipse", method: "Implicit Differentiation", param: "a,b" },
            hyperbola: { name: "Hyperbola", method: "Differentiation", param: "k" },
            rectangularHyperbola: { name: "Rectangular Hyperbola", method: "Differentiation", param: "c" }
        };
        
        // Update formula preview and detect curve type
        curveFamilyInput.addEventListener('input', function() {
            const formula = this.value || 'y = kx';
            formulaPreview.textContent = formula;
            detectCurveType(formula);
        });
        
        // Example button handlers
        exampleButtons.forEach(button => {
            button.addEventListener('click', function() {
                const example = this.getAttribute('data-example');
                curveFamilyInput.value = example;
                curveFamilyInput.dispatchEvent(new Event('input'));
                
                // Clear results
                trajectoryResult.textContent = 'Click "Solve" to see the result.';
                stepByStepResult.textContent = 'The step-by-step solution will appear here.';
                propertiesResult.innerHTML = '• Type of curves: --<br>• Detected method: --<br>• Intersection angle: 90°';
                
                // Clear the graph
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGrid();
            });
        });
        
        // Initialize with example
        window.addEventListener('DOMContentLoaded', function() {
            curveFamilyInput.value = 'y = kx';
            curveFamilyInput.dispatchEvent(new Event('input'));
        });
        
        // Detect curve type from input
        function detectCurveType(formula) {
            formula = formula.toLowerCase().replace(/\s+/g, '');
            
            let type = "unknown";
            let method = "Unknown";
            let param = "";
            
            // Check for circles: x^2 + y^2 = a^2 or similar
            if (formula.includes('x^2') && formula.includes('y^2') && formula.includes('=')) {
                type = "circle";
                method = "Implicit Differentiation";
                param = extractParameter(formula, ['a', 'r', 'c']);
            }
            // Check for ellipses: x^2/a^2 + y^2/b^2 = 1
            else if ((formula.includes('x^2/') || formula.includes('x²/')) && 
                     (formula.includes('y^2/') || formula.includes('y²/')) && 
                     formula.includes('=1')) {
                type = "ellipse";
                method = "Implicit Differentiation";
                param = extractParameter(formula, ['a', 'b']);
            }
            // Check for parabolas: y^2 = 4ax or x^2 = 4ay
            else if ((formula.includes('y^2=') || formula.includes('y²=')) && formula.includes('x')) {
                type = "parabola";
                method = "Differentiation";
                param = extractParameter(formula, ['a']);
            }
            // Check for parabolas: y = kx^2
            else if (formula.includes('y=') && formula.includes('x^2')) {
                type = "parabola";
                method = "Differentiation";
                param = extractParameter(formula, ['k', 'a']);
            }
            // Check for rectangular hyperbolas: xy = c or y = k/x
            else if (formula.includes('xy=') || (formula.includes('y=') && formula.includes('/x'))) {
                type = "rectangularHyperbola";
                method = "Differentiation";
                param = extractParameter(formula, ['c', 'k']);
            }
            // Check for linear: y = kx
            else if (formula.includes('y=') && formula.includes('x') && !formula.includes('^')) {
                type = "linear";
                method = "Differentiation";
                param = extractParameter(formula, ['k', 'm']);
            }
            // Check for hyperbolas: y = k/x^2 or similar
            else if (formula.includes('y=') && formula.includes('/x^2')) {
                type = "hyperbola";
                method = "Differentiation";
                param = extractParameter(formula, ['k']);
            }
            
            // Update detected method display
            detectedMethod.textContent = `${method} (${type})`;
            
            // Auto-fill parameter if not specified by user
            if (param && !variableInput.value.trim()) {
                variableInput.value = param;
            }
            
            return { type, method, param };
        }
        
        // Extract parameter from formula
        function extractParameter(formula, possibleParams) {
            // First check if user already specified a parameter
            if (variableInput.value.trim()) {
                return variableInput.value.trim();
            }
            
            // Try to extract from formula
            for (const param of possibleParams) {
                if (formula.includes(param)) {
                    return param;
                }
            }
            
            // Default to first possible parameter
            return possibleParams[0] || 'k';
        }
        
        // Solve button click handler
        solveBtn.addEventListener('click', function() {
            const curveFamily = curveFamilyInput.value.trim();
            
            if (!curveFamily) {
                alert('Please enter a family of curves.');
                return;
            }
            
            // Show loading indicator
            loadingIndicator.style.display = 'block';
            solveBtn.disabled = true;
            
            // Simulate calculation (in a real app, this would be an API call)
            setTimeout(() => {
                solveOrthogonalTrajectory(curveFamily);
                loadingIndicator.style.display = 'none';
                solveBtn.disabled = false;
            }, 1500);
        });
        
        // Clear button click handler
        clearBtn.addEventListener('click', function() {
            curveFamilyInput.value = '';
            variableInput.value = '';
            document.getElementById('coordinates').value = '';
            curveFamilyInput.dispatchEvent(new Event('input'));
            
            trajectoryResult.textContent = 'Enter a family of curves and click "Solve" to see the result.';
            stepByStepResult.textContent = 'The step-by-step solution will appear here.';
            propertiesResult.innerHTML = '• Type of curves: --<br>• Detected method: --<br>• Intersection angle: 90°';
            
            // Clear the graph
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
        });
        
        // Graph control event listeners
        zoomInBtn.addEventListener('click', function() {
            scale *= 1.2;
            drawGraph();
        });
        
        zoomOutBtn.addEventListener('click', function() {
            scale /= 1.2;
            drawGraph();
        });
        
        resetViewBtn.addEventListener('click', function() {
            scale = 40;
            offsetX = canvas.width / 2;
            offsetY = canvas.height / 2;
            drawGraph();
        });
        
        // Main solver function
        function solveOrthogonalTrajectory(curveFamily) {
            const detected = detectCurveType(curveFamily);
            const coordinates = document.getElementById('coordinates').value.trim();
            
            // Process based on detected type
            let solution, stepByStep, properties, drawFunction;
            
            switch(detected.type) {
                case 'circle':
                    solution = `y = Cx (or x² + y² = C for circles centered at origin)`;
                    stepByStep = `1. Given: ${curveFamily}\n2. Differentiate implicitly: 2x + 2y(dy/dx) = 0\n3. Simplify: dy/dx = -x/y\n4. For orthogonal trajectories: dy/dx = y/x\n5. Separate variables: dy/y = dx/x\n6. Integrate: ln|y| = ln|x| + C\n7. Final: y = Cx`;
                    properties = `• Type of curves: Concentric circles\n• Detected method: ${detected.method}\n• Orthogonal trajectories: Straight lines through origin\n• Intersection angle: 90°`;
                    drawFunction = drawCirclesAndLines;
                    break;
                    
                case 'ellipse':
                    solution = `x²/y² = C or y = Cx`;
                    stepByStep = `1. Given: ${curveFamily}\n2. Differentiate implicitly: (2x/a²) + (2y/b²)(dy/dx) = 0\n3. Simplify: dy/dx = -(b²x)/(a²y)\n4. For orthogonal trajectories: dy/dx = (a²y)/(b²x)\n5. Separate variables: dy/y = (a²/b²)(dx/x)\n6. Integrate: ln|y| = (a²/b²)ln|x| + C\n7. Final: y = Cx^(a²/b²)`;
                    properties = `• Type of curves: Ellipses\n• Detected method: ${detected.method}\n• Orthogonal trajectories: Power functions\n• Intersection angle: 90°`;
                    drawFunction = drawEllipsesAndPowerCurves;
                    break;
                    
                case 'parabola':
                    if (curveFamily.includes('y^2=') || curveFamily.includes('y²=')) {
                        solution = `2x² + y² = C`;
                        stepByStep = `1. Given: ${curveFamily}\n2. For y² = 4ax, differentiate: 2y(dy/dx) = 4a\n3. Simplify: dy/dx = 2a/y\n4. Replace a with y²/(4x): dy/dx = y/(2x)\n5. For orthogonal trajectories: dy/dx = -2x/y\n6. Separate variables: y dy = -2x dx\n7. Integrate: (1/2)y² = -x² + C\n8. Final: 2x² + y² = C`;
                        properties = `• Type of curves: Right-opening parabolas\n• Detected method: ${detected.method}\n• Orthogonal trajectories: Ellipses\n• Intersection angle: 90°`;
                        drawFunction = drawParabolasAndEllipses;
                    } else {
                        solution = `x² + 2y² = C`;
                        stepByStep = `1. Given: ${curveFamily}\n2. Differentiate: dy/dx = 2kx\n3. Replace k with y/x²: dy/dx = 2y/x\n4. For orthogonal trajectories: dy/dx = -x/(2y)\n5. Separate variables: 2y dy = -x dx\n6. Integrate: y² = -(1/2)x² + C\n7. Final: x² + 2y² = C`;
                        properties = `• Type of curves: Parabolas through origin\n• Detected method: ${detected.method}\n• Orthogonal trajectories: Ellipses\n• Intersection angle: 90°`;
                        drawFunction = drawParabolasAndEllipses2;
                    }
                    break;
                    
                case 'rectangularHyperbola':
                    solution = `x² - y² = C`;
                    stepByStep = `1. Given: ${curveFamily}\n2. For xy = c, differentiate implicitly: y + x(dy/dx) = 0\n3. Simplify: dy/dx = -y/x\n4. For orthogonal trajectories: dy/dx = x/y\n5. Separate variables: y dy = x dx\n6. Integrate: (1/2)y² = (1/2)x² + C\n7. Final: x² - y² = C`;
                    properties = `• Type of curves: Rectangular hyperbolas\n• Detected method: ${detected.method}\n• Orthogonal trajectories: Rectangular hyperbolas (rotated)\n• Intersection angle: 90°`;
                    drawFunction = drawRectangularHyperbolas;
                    break;
                    
                case 'linear':
                default:
                    solution = `x² + y² = C`;
                    stepByStep = `1. Given: ${curveFamily}\n2. Differentiate: dy/dx = k\n3. For orthogonal trajectories: dy/dx = -1/k\n4. From original: k = y/x, so -1/k = -x/y\n5. Differential equation: dy/dx = -x/y\n6. Separate variables: y dy = -x dx\n7. Integrate: (1/2)y² = -(1/2)x² + C\n8. Final: x² + y² = C`;
                    properties = `• Type of curves: Straight lines through origin\n• Detected method: ${detected.method}\n• Orthogonal trajectories: Concentric circles\n• Intersection angle: 90°`;
                    drawFunction = drawLinesAndCircles;
                    break;
            }
            
            // If coordinates provided, add specific solution
            if (coordinates) {
                const pointMatch = coordinates.match(/\(?\s*(-?\d+(\.\d+)?)\s*,\s*(-?\d+(\.\d+)?)\s*\)?/);
                if (pointMatch) {
                    const x = parseFloat(pointMatch[1]);
                    const y = parseFloat(pointMatch[3]);
                    solution += `\nSpecific curve through (${x}, ${y}): ${getSpecificSolution(detected.type, x, y)}`;
                }
            }
            
            // Update result displays
            trajectoryResult.textContent = solution;
            stepByStepResult.textContent = stepByStep;
            propertiesResult.textContent = properties;
            
            // Draw the graph
            drawGraph();
            
            // Call specific draw function if available
            if (drawFunction) {
                drawFunction();
            }
        }
        
        // Get specific solution through a point
        function getSpecificSolution(type, x, y) {
            switch(type) {
                case 'circle':
                    return `y = (${y}/${x})x`;
                case 'linear':
                    return `x² + y² = ${(x*x + y*y).toFixed(2)}`;
                case 'parabola':
                    return `x² + 2y² = ${(x*x + 2*y*y).toFixed(2)}`;
                case 'rectangularHyperbola':
                    return `x² - y² = ${(x*x - y*y).toFixed(2)}`;
                default:
                    return `Constant determined by point (${x}, ${y})`;
            }
        }
        
        // Drawing functions
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;
            
            // Vertical lines
            for (let x = offsetX % scale; x < canvas.width; x += scale) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = offsetY % scale; y < canvas.height; y += scale) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(0, offsetY);
            ctx.lineTo(canvas.width, offsetY);
            ctx.stroke();
            
            // Y-axis
            beginPath();
            ctx.moveTo(offsetX, 0);
            ctx.lineTo(offsetX, canvas.height);
            ctx.stroke();
            
            // Draw axis labels
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            
            // X-axis labels
            for (let x = offsetX + scale; x < canvas.width; x += scale) {
                const label = Math.round((x - offsetX) / scale);
                ctx.fillText(label, x - 5, offsetY + 15);
            }
            for (let x = offsetX - scale; x > 0; x -= scale) {
                const label = Math.round((x - offsetX) / scale);
                ctx.fillText(label, x - 5, offsetY + 15);
            }
            
            // Y-axis labels
            for (let y = offsetY + scale; y < canvas.height; y += scale) {
                const label = -Math.round((y - offsetY) / scale);
                ctx.fillText(label, offsetX + 5, y + 3);
            }
            for (let y = offsetY - scale; y > 0; y -= scale) {
                const label = -Math.round((y - offsetY) / scale);
                ctx.fillText(label, offsetX + 5, y + 3);
            }
            
            // Draw origin label
            ctx.fillText('O', offsetX + 5, offsetY - 5);
        }
        
        function drawGraph() {
            drawGrid();
        }
        
        function drawLinesAndCircles() {
            // Draw original family (lines through origin)
            ctx.strokeStyle = '#4b6cb7';
            ctx.lineWidth = 2;
            
            for (let k = -2; k <= 2; k += 0.5) {
                if (k === 0) continue;
                
                ctx.beginPath();
                for (let x = -10; x <= 10; x += 0.1) {
                    const y = k * x;
                    const canvasX = offsetX + x * scale;
                    const canvasY = offsetY - y * scale;
                    
                    if (x === -10) {
                        ctx.moveTo(canvasX, canvasY);
                    } else {
                        ctx.lineTo(canvasX, canvasY);
                    }
                }
                ctx.stroke();
            }
            
            // Draw orthogonal trajectories (circles)
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 2;
            
            for (let r = 1; r <= 4; r++) {
                const radius = r * scale;
                
                ctx.beginPath();
                ctx.arc(offsetX, offsetY, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        function drawCirclesAndLines() {
            // Draw original family (circles)
            ctx.strokeStyle = '#4b6cb7';
            ctx.lineWidth = 2;
            
            for (let r = 1; r <= 4; r++) {
                const radius = r * scale;
                
                ctx.beginPath();
                ctx.arc(offsetX, offsetY, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Draw orthogonal trajectories (lines through origin)
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 2;
            
            for (let k = -2; k <= 2; k += 0.5) {
                if (k === 0) continue;
                
                ctx.beginPath();
                for (let x = -10; x <= 10; x += 0.1) {
                    const y = k * x;
                    const canvasX = offsetX + x * scale;
                    const canvasY = offsetY - y * scale;
                    
                    if (x === -10) {
                        ctx.moveTo(canvasX, canvasY);
                    } else {
                        ctx.line
